% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{quiver}
\usepackage{proof}
\usepackage{tikz-cd}
% \tikzcdset{scale cd/.style={every label/.append style={scale=#1},
%     cells={nodes={scale=#1}}}}
\tikzcdset{row sep/normal=0.22cm}
\tikzcdset{column sep/normal=0.02cm}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
%
\usepackage{amsmath,amssymb,amsfonts}%

%% macros for typesetting
\newcommand{\udl}[1]{\underline{#1}}
\newcommand{\proofbox}[1]{\begin{array}{c} #1 \end{array}}

%% macros for math symbols
\newcommand{\ot}{\otimes}
\newcommand{\cdast}{\circledast}
\newcommand{\Larr}{\Leftarrow}
\newcommand{\Rarr}{\Rightarrow}
\newcommand{\btleft}{\blacktriangleleft}
\newcommand{\btright}{\blacktriangleright}
\newcommand{\sls}{\slash}
\newcommand{\bsls}{\backslash}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mf}[1]{\mathsf{#1}}
\newcommand{\vars}[1]{\mf{var} (#1)}
\newcommand{\gs}[1]{\sigma_{X} (#1)}
\newcommand{\GG}{\Gamma}
\newcommand{\Gg}{\gamma}
\newcommand{\GD}{\Delta}
\newcommand{\Gd}{\delta}
\newcommand{\GL}{\Lambda}
\newcommand{\Gl}{\lambda}

%% macros for acronyms 
\newcommand{\MIP}{\textsf{MIP}}
\newcommand{\MIPeq}{{\textsf{MIP}{\circeq}}}
\newcommand{\FL}{$\mathtt{FL}$}
\newcommand{\Lam}{$\mathtt{L}$}
\newcommand{\LPfree}{$\mathtt{L}_{\Rarr, \Larr}$}
\newcommand{\NL}{$\mathtt{NL}$}

%% macros for derivations
\newcommand{\vd}{\vdash}
\newcommand{\ax}{\mathsf{ax}}
\newcommand{\tl}{{\otimes}\mathsf{L}}
\newcommand{\tr}{{\otimes}\mathsf{R}}
\newcommand{\Ll}{{\Larr}\mathsf{L}}
\newcommand{\Lr}{{\Larr}\mathsf{R}}
\newcommand{\Rl}{{\Rarr}\mathsf{L}}
\newcommand{\Rr}{{\Rarr}\mathsf{R}}
\newcommand{\cut}{\mf{cut}}

%% commands for Agda stuff
\newcommand{\At}{\mathsf{At}}
\newcommand{\at}{\mathsf{at}}
\newcommand{\Fma}{\mathsf{Fma}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\Tree}{\mathsf{Tree}}
\newcommand{\Path}{\mathsf{Path}}
\newcommand{\pathT}[1]{\mathsf{Path} ~ #1}
\newcommand{\append}{+\!\!+}
\newcommand{\Sub}{\mathsf{sub}}
\newcommand{\sub}[2]{\mathsf{sub} ~ #1 ~ #2}
\newcommand{\where}{\mathsf{where}}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\record}{\mathsf{record}}
\newcommand{\field}{\mathsf{field}}
\newcommand{\subst}{\mathsf{subst}}
\newcommand{\Same}{\mathsf{Same}}
\newcommand{\ContainsLeft}{{\in}\mathsf{Left}}
\newcommand{\ContainsRight}{{\in}\mathsf{Right}}
\newcommand{\LeftRight}{\mathsf{Disj}}
\newcommand{\subcases}{\mathsf{SubEq}}
\newcommand{\oneeqtwo}{\mathsf{case}_1}%{\mathsf{1{\equiv}2}}
\newcommand{\twogtLone}{\mathsf{case}_2}%{\mathsf{2{>}L1}}
\newcommand{\twogtRone}{\mathsf{case}_3}%{\mathsf{2{>}R1}}
\newcommand{\onegtLtwo}{\mathsf{case}_4}%{\mathsf{1{>}L2}}
\newcommand{\onegtRtwo}{\mathsf{case}_5}%{\mathsf{1{>}R2}}
\newcommand{\oneLtwoR}{\mathsf{case}_6}%{\mathsf{1\sls \bsls 2}}
\newcommand{\oneRtwoL}{\mathsf{case}_7}%{\mathsf{2\sls \bsls 1}}
\newcommand{\subeq}{\mathsf{subeq}}
\newcommand{\inT}{\in^{\mf{T}}}


\newcommand{\niccolo}[1]{\textcolor{red}{NV: #1}}
\newcommand{\cheng}[1]{\textcolor{blue}{CSW: #1}}

\begin{document}
%
\title{Proof-relevant Maehara Interpolation of Associative Lambek Calculi}
%
\titlerunning{Proof-relevant Interpolation of Associative Lambek Calculi}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Niccol{\`o} Veltri\orcidID{0000-0002-7230-3436} \and
Cheng-Syuan Wan \orcidID{0000-0003-2053-1688}}
%
\authorrunning{N. Veltri and C.-S. Wan}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Tallinn University of Technology, Tallinn, Estonia
\\
\email{\{niccolo,cswan\}@cs.ioc.ee}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  This paper presents a formalization of the nonassociative Lambek calculus in the Agda proof assistant. %, focusing on two major proof-theoretic properties: cut admissibility and Maehara interpolation. 
  The sequent calculus for this logic has sequents with binary trees as antecedents, in which formulae are stored as leaves. The shape of the antecedents creates subtleties when proving logical properties, since in many cases one needs to analyze equalities involving sequentially-composed trees. We formally characterize these equalities and show how to employ the resulting technical lemma to prove cut admissibility and the Maehara interpolation properly, which implies Craig interpolation. We show that both the cut rule and the interpolation procedure are well-defined wrt.\ a certain notion of equivalence of derivations. We additionally prove a proof-relevant version of Maehara interpolation, exhibiting the interpolation procedure as a right inverse of the admissible cut rule. 
  %Our work, especially the case distinction type defined here, aims to serve as a foundation for further research and formalization on nonassociative Lambek calculus.
\keywords{Lambek calculus \and Agda \and cut admissibility \and Maehara interpolation \and proof-relevant interpolation}
\end{abstract}
%
%
%

\section{Introduction}
From the perspective of sequent calculus, substructural logics are characterized by the absence of at least one structural rule. A notable instance is Lambek's syntactic calculus \cite{lambek:mathematics:58}, which forbids the structural rules of weakening, contraction and exchange. Its non-associative variant, also introduced by Lambek \cite{Lambek1961}, further disallows associativity.
% also introduced by Lambek \cite{Lambek1961}, disallows associativity as well.
The Lambek calculus (both its associative and nonassociative variants) has been extensively studied in the literature, especially for its linguistic applications \cite{moot:categorial:2012}.
%While Lambek calculus has different presentations, including axiomatic (or syntactic), natural deduction, and sequent calculus, we focus primarily on the proof-theoretic aspect, specifically the sequent calculus formulation.

In its sequent calculus presentation, sequents in the associative Lambek calculus (\Lam) are of the form $\GG \vd C$, where $\GG$ is a \emph{list} of formulae and $C$ is a single formula, while sequents in the nonassociative Lambek calculus (\NL) are of the form $T \vd C$ where $T$ is a \emph{binary tree} in which formulae are stored in the leaves.
This structural difference makes the proofs of logical properties for \NL\ trickier than for the associative variant.
For example, when proving cut admissibility, in certain cases, one must determine whether the cut formula coincides with the principal formula of the conclusion. For \Lam, the flat antecedents make the situation clear: there are three possibilities--either the cut formula is to the left of the principal formula, to the right, or it is the principal formula itself.

For \NL, the situation is more involved, as there are more cases to examine. %while the case distinction follows similar principles, the hierarchical tree structure obscures these relationships.
For example, consider the proof of cut admissibility, in which we wish to compose the derivations of sequents $U \vdash D$ and $\mc{C}[D] \vd C$. Here $\mc{C}$ is a context, i.e. a tree with a hole, and $\mc{C}[D]$ is the tree resulting from plugging the formula $D$ in the hole. If the derivation of the second sequent ends with an application of the left $\Rl$-introduction rule,
then its antecedent is of the form $\mc{C}'[U' , A \Rarr B]$ for some context $\mc{C}'$, tree $U'$ and formulae $A,B$ (where $\mc{C}'[U',A\Rarr B]$ is the tree arising from substituting the tree $(U', A\Rarr B)$ in context $\mc{C}'$). This means that we are given an equality of trees $\mc{C}[D]=\mc{C}'[U',A \Rarr B]$ and we need to precisely characterize the structural relationship between the cut formula $D$ and the tree $(U,A \Rarr B)$ within the contexts $\mc{C}$ and $\mc{C}'$.
%$\ot$-introduction rule, then its antecedent is of the form $T'[A \ot B]$ for some context $T'$ and formulae $A,B$. This means that we are given an equality of trees $T[D]=T'[A \ot B]$ and we need to precisely characterize the structural relationship between the tensor formula $A \ot B$ and the cut formula $D$ within these trees.
This relationship is not as simple as in the associative Lambek calculus, it involves a more complex splitting of the contexts from which more cases arise.

We can intuitively understand what occurs in the proof of cut admissibility, since it is not too difficult to compute all possible cases. However, what about more complex properties?  For example, consider proving that the admissible cut rule is associative, i.e. the two ways of cutting three sequents of the form $U \vdash D$, $\mc{C}[D] \vdash E$ and $\mc{C}'[E] \vdash C$ produce equal derivations. Because of the large number of cases arising from the induction on the shape of derivations and, mostly, from the analysis of equalities of trees discussed in the previous paragraph, establishing the associativity of cut becomes very challenging to perform with pen and paper, as it is hard to keep track of all the possible cases to consider.
On the other hand, interactive theorem provers are very good tools for dealing with large inductive proofs and keeping track of all existing proof obligations.

%This need leads us to consider a formal verification of the \NL. Our approach involves paths in trees, allowing each subtree to be represented as a substitution along a path in the original tree. This transforms the problem of determining relative positions between different subtrees into a formalizable question about the relationship between two paths in a tree.
%For example, if two formulae $A$ and $B$ are in a tree with paths $p_1$ and $p_2$ respectively, and these paths are disjoint (diverging at some point), then there must exist some common path $q$ and two paths $q_1$ and $q_2$ after divergence such that $p_1$ equals the path concatenation of $q$ and $q_1$, while $p_2$ equals the concatenation of $q$ and $q_2$.

In this work, we present the formalization of the sequent calculus for \NL\ and its metatheory in the Agda proof assistant. We start by formally describing all possible cases arising from equalities of sequentially-composed trees of the form $\mc{C}[U]=\mc{C}'[U']$, which is the main technical lemma that we employ in the proof of logical properties. In particular, the proof of cut admissibility and the establishment of properties of the admissible cut rule: associativity, commutativity and unitality wrt.\ the axiom rule.
%Formalization of mathematics and logics has become a trend in both theoretical computer science and mathematics. While there are many suitable proof assistants (e.g., Agda, Coq, HOL4, and Lean), we choose Agda because its code is more mathematical in style and the process of proving theorems resembles providing algorithms to compute desired terms in the target type.
%\cheng{Maybe here can be some more explanation about why formalization is important}.

%Within proof theory, interpolation properties serve as fundamental property of a logic and of interests by different logicians.
Successively, we present the formal proof of the Maehara interpolation property (\MIP), originating from Maehara's proof of Craig interpolation for classical logic \cite{maehara1961}.
Maehara's method has been applied and adapted to several logics, especially to substructural logics that admit a cut-free sequent calculus \cite{ono:proof:nonclassical:1998}. \MIP\ states that, given a sequent $\mc{C}[U] \vdash C$, there exist a formula $D$ and derivations of sequents $U \vdash D$ and $\mc{C}[D] \vdash C$, such that all the atomic formulae appearing in $D$ appear also in $U$, as well as in $\mc{C},C$.
More precisely, we formalize a proof-relevant (in the sense of \v{C}ubri{\'c} \cite{Cubric1994} and Saurin \cite{Saurin2024}) variant of \MIP: we aim to capture not only the existence of interpolants but also their relationship to the admissible cut rule. In order to achieve this, we first introduce an equivalence relation $\circeq$ on derivations, capturing all the possible permutative conversions. We then show that both the cut rule and the interpolation procedure are well-defined wrt. to the relation $\circeq$. %e.g. if we interpolate on two equivalent derivations, then their interpolants are identical and the corresponding derivations are pairly equivalent.
 Then we show that the interpolation procedure is a right inverse of the admissible cut rule, in the sense that running the interpolation algorithm on a derivation $f$ of a sequent $\mc{C}[U] \vdash C$ and successively cutting the resulting two derivations along the interpolant formula results in a derivation that is $\circeq$-related to $f$.
%i.e. if we interpolate on two equivalent derivations, then their interpolants are identical and the corresponding derivations are pairly equivalent.

%In this paper, we formalize \NL\ and prove properties in Agda: $(i)$ cut-elimination, $(ii)$ Maehara interpolation, $(iii)$ proof-relevant interpolation, and $(iv)$ \linebreak well-definedness of the Maehara interpolation procedure with respect to equivalence of derivations.
Summarizing, this work makes the following contributions: $(i)$ we formalize a technical lemma for dealing with equalities of the form $\mc{C}[U] = \mc{C}'[U']$; $(ii)$ we employ the lemma to formally define effective procedures for cut admissibility and Maehara (and consequently Craig) interpolation; $(iii)$ we prove proof-relevant versions of the latter, by introducing an equivalence of derivations $\circeq$ and formally establishing many properties of the defined procedures: cut is associative, commutative and unital; cut and interpolation are well-defined wrt. $\circeq$; interpolation is a right inverse of cut. We notice that contribution $(iii)$ is completely novel in the study of the metatheory of \NL, not only its mechanization in a proof assistant.
%The paper proceeds as follows. We begin with the foundations of our formalization, including definitions of trees, paths in trees, substitutions, and case distinctions for identifying relationships between paths. Next, we introduce the sequent calculus of \NL\ and formalize cut-elimination. The subsequent section addresses equivalence of derivations and properties of the $\cut$ rule.
%In the final sections, we formally prove Maehara interpolation and proof-relevant interpolation to demonstrate that our formalization provides a correct and usable strategy. It is worth noting that the proof-relevant interpolation results presented here are novel contributions to the study of \NL.

\paragraph{Related work.}
% \\
% Several previous works have formalized aspects of nonassociative Lambek calculus:
There is some previous work on the formalization of \NL\ in proof assistants. Chapter 4 of Anoun et al.'s tutorial \cite{anoun2004proof} presents a Coq formalization of the nonassociative Lambek calculus, covering axiomatic calculus, natural deduction and sequent calculus. Tian \cite{tian2017formalized} ported the above Coq formalization to HOL4. Kokke \cite{kokke2017formalising} formalized the nonassociative Lambek-Grishin calculus in Agda. %However, their work focused on axiomatic calculus, where both the antecedent and succedent are single formulae, in contrast to the sequent calculus with tree as antecedents that we formalize.
These earlier formalizations primarily focus on implementing the calculi and proving cut admissibility with potential linguistic applications in mind.
%Our project takes a more proof-theoretic perspective, formally verify  focusing on the equational theory of proofs. We formalize not only cut-elimination but also extend to Maehara interpolation, proof-relevant interpolation, and demonstrate that Maehara interpolation is well-defined with respect to equivalence of derivations.

Craig interpolation for intuitionistic logic has been formalized in Isabelle/HOL by Ridge \cite{ridge:2006} and in Nominal Isabelle by Chapman et al. \cite{ChapmanMU08}. For  classical logic, there is a formalization in Isabelle/HOL by Michealis and Nipkow \cite{michealis:2017}. Recently,  F{\'{e}}r{\'{e}}e and van Gool \cite{feree:2023} have formalized uniform interpolation for intuitionistic logic in Coq, which was extended to a class of modal logic by F{\'{e}}r{\'{e}}e et al. \cite{feree:24}. As far as we know, there are no formalized proofs of Craig/Maehara interpolation for substructural logics in the literature.

We would like to add that the (pen-and-paper, non-formalized) proof of Maehara interpolation for \NL\ is uncommon in the literature, as we were unable to find a reference for it. For \NL\ (and its extensions with modalities, additive connectives, etc.) researchers have traditionally been interested in other interpolation properties, involving a different condition on atomic formulae, which are useful for establishing the finite model property and the relationship between Lambek grammars and context-free grammars \cite{jager:04,buszkowski:2009,buszkowski:2010,lin:14}.
%Our method is more akin to traditional Maehara's method because our interest lies in a more refined analysis based on equivalence of derivations.

\paragraph{Formalization}
The Agda formalization is freely available online at: \url{https://github.com/cswphilo/nonassociative-Lambek/tree/main/code}.



\section{Sequent Calculus}\label{sec:seqcalc}

Formulae of \Lam\ are inductively generated by the grammar $A, B ::= X \ | \ A \Larr B \ | \ B \Rarr A \ | \ A \ot B$, where $X$ is drawn from a set $\mathsf{At}$ of atomic formulae,
The formulae of \LPfree\ are obtained by excluding the formulae of the shape $A \ot B$ from the set of formulae of \Lam.

Derivations of \Lam\ (\LPfree) are inductively generated by the following rules (excluding $\tr$ and $\tl$):
\begin{equation}\label{eq:seqcalc}
\begin{array}{c}
  \infer[\ax]{A \vd A}{}
  \quad
  \infer[\Rr]{\GG \vd A \Rarr B}{A , \GG \vd B} 
  \quad
  \infer[\Lr]{\GG \vd B \Larr A}{\GG , A \vd B}
  \\[7pt]
  \infer[\Rl]{\GG , A \Rarr B , \GL \vd C}{
    \GD \vd A
    &
    \GG , B , \GL \vd C
  }
  \quad
  \infer[\Ll]{\GG , B \Larr A , \GL \vd C}{
    U \vd A
    &
    \GG , B , \GL \vd C
  }
  \\[7pt]
  \infer[\tr]{\GG , \GD \vd A \ot B}{
    \GG \vd A
    &
    \GD \vd B
  }
  \quad
  \infer[\tl]{\GG , A \ot B , \GD \vd C}{
    \GG , A , B , \GD \vd C
  }
\end{array}
\end{equation}


\begin{theorem}
  The cut rule
  \[
  \infer[\cut]{\GG , \GD , \GL \vd C}{
    \deduce{\GD \vd A}{f}
    &
    \deduce{\GG , A , \GL \vd C}{g}
  }
  \]
   is admissible in both \Lam\ and \LPfree.
\end{theorem}

\begin{theorem}
  mip for \Lam, cite roorda and moot and retore
\end{theorem}

\begin{theorem}
  mip for \LPfree, cite pentus
\end{theorem}

\[
calculus\ decorated\ by\ interpolant\ triples
\]

\begin{enumerate}
  \item calculi
  \item cut admissibility, just theorems
  \item Maehara interpolation, kind of also well known but pay some more attention on multi-interpolation
  \item interpolation will then induce a calculus decorated with interpolant triples
  \begin{enumerate}
    \item show some example rules
  \end{enumerate}
  \item equivalence of derivations
  \item proof-relevant interpolation for both, i.e. cut is the left inverse of interpolation
  \item well-definedness of interpolation procedure wrt. equivalence of derivations, in the nonassociative case, it was kind of trivial but in the associative case, there are something interesting, 
  \begin{enumerate}
    \item first, not all interpolant formulae from a pair of equivalent derivations are the same, they can be logically equivalent or even weaker, only one way of derivability.
    \item then a good notion to characterize them will be the zig-zag equivalence.
    \item After that, we show the well-definedness for both assoc Lam and prod-free Lam with the examples appear in both calculi, i.e.\ the curry and uncurry formulae, $(E \ot D) \Rarr F$ and $D \Rarr (E \Rarr F)$ for  ->L->L-assoc, and $(F \Larr E) \ot F$ and $F \Larr (D \Rarr E)$ for ->L<-L-comm.
  \end{enumerate}  
  \item maybe it will be good to think about computational interpolation of this behavior but I am not sure about that.
\end{enumerate}


\section{Equivalence of Derivations}
In our Agda formalization, a sequent $T \vdash C$ is a type which in general is not a proposition, i.e. it may have multiple distinct terms/derivations.
Some of these derivations are ``morally'' the same, they only differ by some permutation of rules in their proof tree.
In the literature on substructural logic, one would say that these derivations are different sequentialization of the same proof net.
We introduce a congruence relation $\circeq$ relating precisely these derivations in \NL. 
The congruence $\circeq$ is generated by twenty-seven permutative conversions, of which we present three in Figure \ref{fig:example:perm:conversion}.
These are representative examples of three classes of permutative conversions:  $(i)$ left rules permute with right rules ($\tl$ permutes with $\Rr$ in the figure); $(ii)$ sequential application of left rules can be permuted ($\tl$ permutes with $\Rl$ in the figure); $(iii)$ parallel application of left rules can be permuted ($\Rl$ permutes with $\Rl$ in the figure).
% \begin{figure}[t]
%   \[
%   \scalebox{0.91}{$
%   \begin{array}{rcl}
%     \proofbox{
%       \infer[\tl]{\mc{C}[A \ot B] \vd A' \Rarr B'}{
%         \infer[\Rr]{\mc{C}[A , B] \vd A' \Rarr B'}{
%           \deduce{A' , \mc{C}[A , B] \vd B'}{f}
%         }
%       }
%     }
%     &\circeq&
%     \proofbox{
%       \infer[\Rr]{\mc{C}[A \ot B] \vd A' \Rarr B'}{
%         \infer[\tl]{A' , \mc{C}[A \ot B] \vd B'}{
%           \deduce{A' , \mc{C}[A , B] \vd B'}{f}
%         }
%       }
%     }
%     \\
%     \proofbox{
%       \infer[\tl]{\mc{C}'[\mc{C}[A' \ot B'], A \Rarr B] \vd C}{
%         \infer[\Rl]{\mc{C}'[\mc{C}[A' , B'], A \Rarr B] \vd C}{
%           \deduce{\mc{C}[A' , B'] \vd A}{f}
%           &
%           \deduce{\mc{C}'[B] \vd C}{g}
%         }
%       }
%     }
%     &\circeq&
%     \proofbox{
%       \infer[\Rl]{\mc{C}'[\mc{C}[A' \ot B'], A \Rarr B] \vd C}{
%         \infer[\tl]{\mc{C}[A' \ot B'] \vd A}{
%           \deduce{\mc{C}[A' , B'] \vd A}{f}
%         }
%         &
%         \deduce{\mc{C}'[B] \vd C}{g}
%       }
%     }
%     \\
%     \proofbox{
%       \infer[\Rl]{\mc{C}[\mc{C}_1[U , A \Rarr B] , \mc{C}_2[V , A' \Rarr B']] \vd C}{
%         \deduce{U \vd A}{f}
%         &
%         \infer[\Rl]{\mc{C}[\mc{C}_1[B] , \mc{C}_2[V , A' \Rarr B']] \vd C}{
%           \deduce{V \vd A'}{f'}
%           &
%           \deduce{\mc{C}[\mc{C}_1[B] , \mc{C}_2[B']] \vd C}{g}
%         }
%       }
%     }
%     &\circeq&
%     \proofbox{
%       \infer[\Rl]{\mc{C}[\mc{C}_1[U , A \Rarr B] , \mc{C}_2[V , A' \Rarr B']] \vd C}{
%         \deduce{V \vd A'}{f'}
%         &
%         \infer[\Rl]{\mc{C}[\mc{C}_1[U , A \Rarr B] , \mc{C}_2[B']] \vd C}{
%           \deduce{U \vd A'}{f}
%           &
%           \deduce{\mc{C}[\mc{C}_1[B] , \mc{C}_2[B']] \vd C}{g}
%         }
%       }
%     }
%   \end{array}
%   $}
%   \]
%   \caption{Examples of permutative conversions}
%   \label{fig:example:perm:conversion}
% \end{figure}

In Agda, the relation $\circeq$ is implemented as an inductive type family indexed over pairs of derivations. This means that $f \circeq g$ is a type for each $f,g : T \vdash C$, whose terms are proofs of $f$ being equivalent to $g$.
The Agda definition of $\circeq$ includes: $(i)$ a constructor for each permutative conversion, $(ii)$ constructors for reflexivity, symmetry and transitivity of $\circeq$, and  $(iii)$ constructors evidencing the compatibility of $\circeq$ with the inference rules of \NL, i.e. that $\circeq$ is a congruence relation.
Here we present three indicative examples, one for each class of equational generators: $(i$) the constructor $\tl\Rr$ associated to the first example of permutative conversion in Figure \ref{fig:example:perm:conversion}; $(ii)$ the constructor $\mathsf{sym}{\circeq}$ witnessing that $\circeq$ is a symmetric relation; $(iii)$ the constructor $\mathsf{cong}\Rl$ witnessing the compatibility of $\circeq$ wrt. $\Rl$.
\[
\begin{array}{rcl}
\tl\Rr &:& (p : \pathT{T}) ~ (f : \eta A' \cdast \sub{p}{(\eta A \cdast \eta B)} \vd B') \\
&\to& \tl ~ p ~ (\Rr ~ f) ~ \circeq \Rr ~ (\tl ~ (\bullet \btright p) ~ f)  \\[2pt]
\mathsf{sym}{\circeq} &:& (f ~ g : T \vd C) ~ (eq : f \circeq g) \to g \circeq f \\[2pt]
\mathsf{cong}\Rl &:& (p : \pathT{T}) ~ (f ~ f' : U \vd A) ~ (g ~ g' : \sub{p}{\eta B} \vd C) \\
& \to & (eq : f \circeq f') ~ (eq' : g \circeq g') \to \, \Rl ~ p ~ f ~ g \circeq \Rl ~ p ~ f' ~ g'
\end{array}
\]

The admissible cut rule satisfies the set of equivalences in Figure \ref{fig:cut:left:rules}, which shows that $\cut$ and left rules in the first premise are permutable up to $\circeq$. These equations arise from our implementation of cut admissibility, which proceeds by structural recursion on the second premise. If $\cut$ were defined by pattern-matching on the first premise instead, as discussed in Remark \ref{remark}, then we would have  equivalences showing that $\cut$ and right rules in the second premise are permutable up to $\circeq$.
In Agda, the proof of this equivalence also proceeds by induction on the second premise.
  \begin{figure}[t]
  \[
  \scalebox{0.9}{$
  \begin{array}{rcl}
    \proofbox{
        \infer[\cut]{\mc{C}[\mc{C}'[V , A \Rarr B]] \vd C}{
      \infer[\Rl]{\mc{C}'[V , A \Rarr B] \vd D}{
        \deduce{V \vd A}{f}
        &
        \deduce{\mc{C}'[B] \vd D}{h}
      }
      &
      \deduce{\mc{C}[D] \vd C}{g}
    }
    }
    &\circeq&
    \proofbox{
      \infer[\Rl]{\mc{C}[\mc{C}'[V , A \Rarr B]] \vd C}{
        \deduce{V \vd A}{f}
        &
        \infer[\cut]{\mc{C}[\mc{C}'[B]] \vd C}{
          \deduce{\mc{C}'[B] \vd D}{h}
          &
          \deduce{\mc{C}[D] \vd C}{g}
        }
      }
    }
    \\[5pt]
    \proofbox{
        \infer[\cut]{\mc{C}[\mc{C}'[B \Larr A , V]] \vd C}{
      \infer[\Ll]{\mc{C}'[B \Larr A , V] \vd D}{
        \deduce{V \vd A}{f}
        &
        \deduce{\mc{C}'[B] \vd D}{h}
      }
      &
      \deduce{\mc{C}[D] \vd C}{g}
    }
    }
    &\circeq&
    \proofbox{
      \infer[\Ll]{\mc{C}[\mc{C}'[B \Larr A , V]] \vd C}{
        \deduce{V \vd A}{f}
        &
        \infer[\cut]{\mc{C}[\mc{C}'[B]] \vd C}{
          \deduce{\mc{C}'[B] \vd D}{h}
          &
          \deduce{\mc{C}[D] \vd C}{g}
        }
      }
    }
    \\[5pt]
    \proofbox{
      \infer[\cut]{\mc{C}[\mc{C}'[A \ot B]] \vd C}{
        \infer[\tl]{\mc{C}'[A \ot B] \vd D}{
          \deduce{\mc{C}'[A , B] \vd D}{h}
        }
        &
        \deduce{\mc{C}[D] \vd C}{g}
      }
    }
    &\circeq&
    \proofbox{
      \infer[\tl]{\mc{C}[\mc{C}'[A \ot B]] \vd C}{
        \infer[\cut]{\mc{C}[\mc{C}'[A , B]] \vd D}{
          \deduce{\mc{C}'[A , B] \vd D}{h}
          &
          \deduce{\mc{C}[D] \vd C}{g}
        }
      }
    }
  \end{array}
  $}
  \]
    \caption{Permutation of $\cut$ and left rules}
    \label{fig:cut:left:rules}
  \end{figure}
% cut⇒L≗ : ∀ {T U V W A B C D} (p : Path T) (q : Path U)
%   → {f : V ⊢ A}
%   → (h : sub q (η B) ⊢ D)
%   → (g : W ⊢ C)
%   → (eq : W ≡ sub p (η D))
%   → cut p (⇒L q f h) (subst-cxt eq g) refl ≗ ⇒L (p ++ q) f (cut p h (subst-cxt eq g) refl)

% cut⇐L≗ : ∀ {T U V W A B C D} (p : Path T) (q : Path U)
%   → {f : V ⊢ A}
%   → (h : sub q (η B) ⊢ D)
%   → (g : W ⊢ C)
%   → (eq : W ≡ sub p (η D))
%   → cut p (⇐L q f h) (subst-cxt eq g) refl ≗ ⇐L (p ++ q) f (cut p h (subst-cxt eq g) refl)

% cut⊗L≗ : ∀ {T U W A B C D} (p : Path T) (q : Path U)
%   → (h : sub q (η A ⊛ η B) ⊢ D)
%   → (g : W ⊢ C)
%   → (eq : W ≡ sub p (η D))
%   → cut p (⊗L q h) (subst-cxt eq g) refl ≗ ⊗L (p ++ q) (cut p h (subst-cxt eq g) refl)

  Since we consider $\circeq$-related derivations as being equal, all admissible rules (e.g. $\cut$) and constructions on derivations (e.g. Maehara interpolation in the next section) must be well-defined wrt.\ to $\circeq$. This means that the $\cut$ procedure must produce $\circeq$-related outputs when applied to $\circeq$-related inputs. In Agda, this statement can be split in the following two terms, which are defined by mutual induction, witnessing that $\cut$ respects $\circeq$ in each of its arguments:
\[
\begin{array}{l}
  \cut{\circeq}_1 : \{f~f' : U \vdash D\} ~\{g : W \vdash C\}
  ~ (eq_1 : W \equiv \sub{p}{\eta~ D})
  ~ (eq_2 : f \circeq f')
  \\
  \quad \to 
  \cut ~f~g ~eq_1 \circeq \cut ~f'~g~eq_1
  \\[2pt]
  \cut{\circeq}_2 : \{f : U \vdash D\} \{g ~g': W \vdash C\}
  ~ (eq_1 : W \equiv \sub{p}{\eta~ D})
  ~ (eq_2 : g \circeq g')
  \\
  \quad \to 
  \cut ~f~g ~eq_1 \circeq \cut ~f~g'~eq_1
\end{array}
\]
We define $\cut{\circeq}_2$ by pattern-matching on $eq_2$, i.e. the proof of equivalence of derivations. 
The main challenge is handling the thirty-six cases that arise from the pattern-match, with further numerous subcases arising from the applications of $\subeq$, which are necessary for the $\cut$ function to compute. The use of Agda was invaluable here, helping us examine all possible cases systematically and verifying the correctness of the completed proof.

\section{Proof-Relevant Maehara Interpolation}
%In this section, we introduce three aspects of interpolation for nonassociative Lambek calculus: Maehara interpolation, proof-relevant interpolation, and showing that Maehara interpolation is well-defined with respect to equivalence of derivations.

The Maehara interpolation property (\MIP) is a property of a cut-free sequent calculus. 
It originates from Maehara's proof of Craig interpolation for the sequent calculus for classical logic $\mathtt{LK}$ \cite{maehara1961}.
The method has been subsequently used to prove Craig interpolation for various logics.
For the associative Lambek calculus, \MIP\ is formulated as follows \cite{ono:proof:nonclassical:1998}: given $f : \GG \vdash C$ and a partition $\langle \GG_0, \GG_1, \GG_2 \rangle$ of $\GG$, there exist a formula $D$ and two derivations $g : \GG_1 \vdash D$ and $h : \GG_0, D, \GG_2 \vdash C$ such that $\vars{D} \subseteq \vars{\GG_0} \cap \vars{\GG_0, \GG_1, C}$.
Here  $\vars{A}$ denotes the set of atomic formulae appearing in $A$, which can be extended naturally to lists of formulae.

% \FL\ without additive connectives enjoys an stronger form of Maehara interpolation that replaces variable condition with a more refined variable \emph{multiplicity} condition \cite{moot:categorial:2012}.
% This refinement tracks the precise number of occurrences of each atomic formula. Let us denote by $\gs{A}$ the count of occurrences of atomic formula $X$ within formula $A$, and extend this notation to $\gs{\GG}$ representing the occurrence count of $X$ across a sequence of formulae $\GG$.
% Under this perspective, the strengthened version of Maehara interpolation is formulated as follows:
% \begin{description}
%   \item[(\MIP~for \FL~with variable multiplicity condition)] Given $f : \GG \vdash C$ and a partition $\langle \GG_0, \GG_1, \GG_2 \rangle$ of $\GG$, there exist a formula $D$ and two derivations $g : \GG_1 \vdash D$ and $h : \GG_0, D, \GG_2 \vdash C$ such that $\gs{D} \leq \gs{\GG_1}$ and $\gs{D} \leq \gs{\GG_0, \GG_2 , C}$ for all atomic $X$.
% \end{description}
% In his PhD thesis \cite{roorda1991}, Roorda considered a even more stronger variable multiplicity condition, not merely the number of occurrences of atomic formulae but also characterizing the \emph{positive and negative} occurrences of atomic formulae in interpolants. Let $\mathsf{At}^{+}_{X}(A)$ be the multiset of positive occurrences of the atomic formula $X$ in $A$, and let $\mathsf{At}^{-}_{X}(A)$ be the multiset of negative occurrences of the atomic formula $X$ in $A$.
% Roorda's version of Maehara interpolation can be formulated as follows:
% \begin{description}
%   \item[(\MIP~for \FL~with variable polarity condition)] Given $f : \GG \vdash C$ and a partition $\langle \GG_0, \GG_1, \GG_2 \rangle$ of $\GG$, there exist a formula $D$ and two derivations $g : \GG_1 \vdash D$ and $h : \GG_0, D, \GG_2 \vdash C$ such that given $p \in \{ +,-\}$ and any atomic formula $X$, there is an injective function from $\mathsf{At}^{p}_{X}(D)$ to $\mathsf{At}^{p}_{X}(\GG_1)$, and an injective function from $\mathsf{At}^{p}_{X}(D)$ to the multiset union of $\mathsf{At}^{\neg p}_{X}(\GG_0, \GG_2)$ and $\mathsf{At}^{p}_{X}(C)$. Here $\neg p$ denotes the opposite polarity of $p$, i.e. $\neg + = -$ and $\neg - = +$.
% \end{description}

%Interpolation proofs for various extensions of nonassociative Lambek calculus often depart from the Maehara approach. These alternative methods typically rely on identifying a closed set of formulae that can appear in derivations and proving that interpolant formulae always belong to this set \cite{buszkowski:2009,buszkowski:2010}. Such interpolation theorems primarily serve to establish further properties of the target logic, such as the finite model property, rather than directly addressing our current focus.

\MIP\ for \NL\ has the following form: given a derivation $f : \mc{C}[U]\vd C$, there exist a formula $D$ and two derivations $g : \mc{C}[D] \vd C$ and $h : U \vd D$ such that $\vars{D} \subseteq \vars{U} \cap \vars{\mc{C}, C}$.
This property, not including the variable condition (discussed later), is implemented in Agda as the following record type:
\[
\begin{array}{rl}
  \multicolumn{2}{l}{\record \:\:  \MIP ~ (p : \pathT{T}) ~ (U : \Tree) ~ (C : \Fma) : \Set \:\: \where} \\
%  \multicolumn{2}{l}{\quad \mf{constructor} ~ \mf{intrp}} \\
  \multicolumn{2}{l}{\quad \field} \\
  \;\; \quad D &: \Fma \\[0.5pt]
  \;\; \quad g &: \sub{p}{(\eta ~ D)} \vd C \\[0.5pt]
  \;\; \quad h &: U \vd D 
\end{array}
\]
Elements of type $\MIP ~ p ~ U ~C$ are triples consisting of a formula $D$ and two derivations $g$ and $h$.
Proving the Maehara interpolation property translates to constructing the following function:
\[
\begin{array}{l}
\mathsf{mip} : (f : V \vd C) ~ (eq : V \equiv \sub{p}{U}) \to \MIP ~ p ~ U ~C
\end{array}
\]
The construction of the $\mathsf{mip}$ function proceeds by pattern-matching on the derivation $f$.
%, which mirrors the pen-and-paper proofs in \cite{roorda1991,moot:categorial:2012} (for \Lam\ instead of \NL) that use induction on $f$.
Similar to our implementation of cut admissibility, there are cases when we need to determine whether the tree $U$ and the principal formula of the conclusion of a in inference rule coincide. This analysis is again handled by the $\mathsf{subeq}$ function, which helps us systematically identifying and process all possible cases that may arise during the construction.

The variable condition for \MIP\ is implemented in Agda as follows.
We first introduce a type $X \in A$ whose terms correspond to occurrences of the atomic formula $X$ in the formula $A$. This can be lifted to a type $X \inT T$, whose terms are occurrences of $X$ in any formula appearing as a leaf of $T$.
%\[
%\begin{array}{lrl}
%  \multicolumn{3}{l}{\data \:\: \_{\inT}\_ ~ (X : \At) : \Tree \to \Set \:\: \where} \\
%  \;\; \quad \at& &: \forall ~ \{A\} \to X \in A \to X \inT \eta A \\
%  \;\; \quad \mf{left}& &: \forall \{T ~ U\} \to X \inT T \to X \inT T \cdast U \\
%  \;\; \quad \mf{right}& &: \forall \{T ~ U\} \to X \inT U \to X \inT T \cdast U
%\end{array}
%\]
%Each constructor represents a way an atomic formula can appear in a tree: $\at$ indicates that if $X \in \vars{A}$, then $X$ also appears in the set of atomic formulae of the \emph{tree} $A$; $\mf{left}$ means that if $X \in \vars{T}$, then it also appears in the set of atomic formulae of the tree $T \cdast U$ for any $U$; and $\mf{right}$ is the dual case.
%When a tree $U$ is substituted into a context $T[\bullet]$ (resulting in $T[U]$), variables can come from either the context or the substituted tree. We capture this relationship with two functions:
%\[
%\begin{array}{l}
%{\in}\mf{sub}_1 : \forall ~ \{A ~ T ~ U \} ~ (p : \pathT{T}) \to A \inT T \to A \inT \sub{p}{U}
%\\
%{\in}\mf{sub}_2 : \forall ~ \{A ~ T ~ U \} ~ (p : \pathT{T}) \to A \inT U \to A \inT \sub{p}{U}
%\end{array}
%\]
%The function ${\in}\mf{sub}_1$ shows how variables from the original context $T$ propagate to the substituted tree, while ${\in}\mf{sub}_2$ shows how variables from the substituted tree $U$ appear in the substituted tree. Both functions are defined by pattern-matching on the path $p : \pathT{T}$, with ${\in}\mf{sub}_1$ additionally pattern-matching on the witness that $A$ appears in $T$.
The variable condition can then be expressed as a record type:
\[
\begin{array}{rl}
  \multicolumn{2}{l}{\record \:\:  \mf{VarCond}~ (p : \pathT{T}) ~ (U : \Tree) ~ (C ~ D : \Fma) : \Set \:\: \where} \\
  \multicolumn{2}{l}{\quad \field} \\
  \;\; \quad varg &: \forall \{X\} \to X \in D \to X \inT T \uplus X \in C \\[0.5pt]
  \;\; \quad varh &: \forall \{X\} \to X \in D \to X \inT U
\end{array}
\]
Here $\uplus$ is the disjoint union of types in Agda.
Terms of the above type are pairs of functions: $\mf{varg}$ sends each occurrence of atomic formula $X$ in $D$ to an occurrence of $X$ in $T,C$, while $\mf{varh}$ sends occurrences of X in $D$ to occurrence of $X$ in $U$.
In Agda we verify that the interpolant formula $D$ produced by the $\mf{mip}$ procedure satisfies this variable condition by constructing the following function:
\[
\begin{array}{l}
\mf{varcond} : (f : V \vd C) ~ (eq : V \equiv \sub{p}{U}) \to \mf{VarCond} ~ p ~ U ~ C ~ (\MIP.D ~ (\mf{mip} ~ f ~ eq))
\end{array}
\]
The definition of $\mf{varcond}$ follows the structure of $\mf{mip}$, ensuring that the variable condition is preserved through all cases of the interpolation algorithm. In the type above, $\MIP.D ~ (\mf{mip} ~ f ~ eq)$ is the interpolant formula $D$ produced by $\mf{mip} ~ f ~ eq$.

% _∈_ : (X : At) → Fma → Set
% X ∈ at Y = X ≡ Y
% X ∈ (A ⇒ B) = X ∈ A ⊎ X ∈ B
% X ∈ (B ⇐ A) = X ∈ A ⊎ X ∈ B
% X ∈ (A ⊗ B) = X ∈ A ⊎ X ∈ B
  
% data _∈ᵀ_ (X : At) : Tree → Set where
%   at : ∀ {A} → X ∈ A → X ∈ᵀ η A
%   left : ∀ {T U} → X ∈ᵀ T → X ∈ᵀ T ⊛ U
%   right : ∀ {T U} → X ∈ᵀ U → X ∈ᵀ T ⊛ U

% -- _∈ᵀ_ : At → Tree → Set
% -- X ∈ᵀ T = Σ Fma λ A → (X ∈ A) × (A ∈ᵀ T)

% sub∈ : ∀ {A T U} (p : Path T) → A ∈ᵀ sub p U → A ∈ᵀ T ⊎ A ∈ᵀ U
% sub∈ ∙ (at m) = inj₂ (at m)
% sub∈ ∙ (left m) = inj₂ (left m)
% sub∈ ∙ (right m) = inj₂ (right m)
% sub∈ (p ◂ _) (left m) = elim⊎ (λ n → inj₁ (left n)) inj₂ (sub∈ p m)
% sub∈ (p ◂ _) (right m) = inj₁ (right m)
% sub∈ (T ▸ p) (left m) = inj₁ (left m)
% sub∈ (T ▸ p) (right m) = elim⊎ (λ x → inj₁ (right x)) inj₂ (sub∈ p m)

% ∈sub₁ : ∀ {A T U} (p : Path T) → A ∈ᵀ T → A ∈ᵀ sub p U
% ∈sub₁ (p ◂ _) (left m) = left (∈sub₁ p m)
% ∈sub₁ (p ◂ _) (right m) = right m
% ∈sub₁ (_ ▸ p) (left m) = left m
% ∈sub₁ (_ ▸ p) (right m) = right (∈sub₁ p m)

% ∈sub₂ : ∀ {A T U} (p : Path T) → A ∈ᵀ U → A ∈ᵀ sub p U
% ∈sub₂ ∙ m = m
% ∈sub₂ (p ◂ _) m = left (∈sub₂ p m)
% ∈sub₂ (_ ▸ p) m = right (∈sub₂ p m)

% record VarCond (T : Tree) (p : Path T) (U : Tree) (C D : Fma) : Set where
%   constructor var
%   field
%     varg : ∀ {X} → X ∈ D → X ∈ᵀ T ⊎ X ∈ C
%     varh : ∀ {X} → X ∈ D → X ∈ᵀ U

% varcond : ∀ {T} (p : Path T) U {V C}
%   → (f : V ⊢ C) (eq : V ≡ sub p U) 
%   → VarCond T p U C (D (mip' p U f eq))

Similarly to the cut rule, the procedure $\mf{mip}$ must also be well-defined wrt.\ the relation $\circeq$.
To this end, we need to pick an appropriate notion of equivalence of terms of type $\MIP~p~U~C$.
For \NL, we say that two interpolant triples $(D, g, h)$ and $(D', g', h')$ of type $\MIP~p~U~C$ are equivalent when $D \equiv D'$, $g$ is  $\circeq$-related to $g'$ and $h$ is $\circeq$-related to  $h'$. This is a quite strong notion of equivalence, as interpolant formulae $D$ and $D'$ are required to be syntactically equal.
In Agda, equivalences of interpolant triples are terms of the following record type:
\[
\begin{array}{rl}
  \multicolumn{2}{l}{\record \:\:  \MIPeq ~ (m_1 ~ m_2 : \MIP ~ p ~ U ~C) : \Set \:\: \where} \\
%  \multicolumn{2}{l}{\quad \mf{constructor} ~ \mf{intrp}{\circeq}} \\
  \multicolumn{2}{l}{\quad \field} \\
  \;\; \quad eqD &: D \equiv D' \\[0.5pt]
  \;\; \quad eqg &: \subst ~(\lambda x.\ \sub{p}{(\eta ~ x)} \vd C)~eqD~g \circeq g' \\[0.5pt]
  \;\; \quad eqh &: \subst ~(\lambda x.\ U \vd x) ~ eqD ~ h \circeq h'
\end{array}
\]
%Elements of type $\MIP ~ p ~ U ~C$ are triples consisting of a formula $D$ and two derivations $g$ and $h$.
well-definedness of Maehara interpolation wrt.\ $\circeq$ in Agda corresponds to the construction of the function below, which proceeds by pattern-matching on $eq_2$:
%This equivalence relation between interpolant triples leads to a theorem connecting interpolation and equivalence of derivations: when two derivations $f, f': T[U] \vdash C$ are equivalent (i.e. $f \circeq f'$), their corresponding interpolant triples must also be equivalent. Formally:
%\begin{theorem}
%  Given two derivations $f, f' : T[U] \vdash C$, if $f \circeq f'$, then the interpolant triples of $f$ and $f'$ are equivalent.
%\end{theorem}
%The proof of \MIP\ for \NL\ becomes the construction of the following function:
\[
\begin{array}{l}
\mathsf{mip{\circeq}} : \{f ~ f' : V \vd C\}~ (eq_1 : V \equiv \sub{p}{U})
~(eq_2 : f \circeq f')
\\[0.8pt]
\quad \to \MIPeq ~ (\mf{mip} ~ f ~ eq_1) ~ (\mf{mip} ~ f' ~ eq_1)
\end{array}
\]

%\subsection{Proof-Relevant Interpolation}
We have established a procedure $\mathsf{mip}$ for effectively splitting a derivation $f : \mc{C}[U] \vdash C$ into two derivations $g : U \vdash D$ and $h : \mc{C}[D] \vdash C$, with $D$ being ``minimal'' in the sense of satisfying an appropriate variable condition. A natural question arises: what happens when we compose derivations $g$ and $h$ using the admissible cut rule? Intuition suggests that we should recover the original derivation $f$, at least modulo $\circeq$.
Similar questions have been considered by {\v{C}}ubri{\'c} \cite{Cubric1994} for intuitionistic propositional logic and by Saurin \cite{Saurin2024} for (extensions) of classical linear logic. They call \emph{proof-relevant interpolation} the study of interpolation procedures in relationship to the cut rule and equivalence of proofs, like our $\circeq$. In particular, {\v{C}}ubri{\'c} and Saurin show that interpolation procedures are in a way ``right inverses'' of the cut rule. Here we show the same for \NL: 
if $g : \mc{C}[D] \vd C$ and $h : U \vd D$ are derivations obtained by applying the $\mf{mip}$ procedure on a derivation $f: \mc{C}[U] \vd C$, then $\mf{cut}(h, g)$ is $\circeq$-related to $f$.

%Given a derivation $f : V \vdash C$ and an equality proof $eq : V \equiv \text{sub} \ p \ U$, we first apply the Maehara interpolation procedure $\mathsf{mip}$ on them, obtaining an interpolant formula $D$ and two derivations $\mathsf{MIP}.g \ (\mathsf{mip} \ f \ eq)$ and $\mathsf{MIP}.h \ (\mathsf{mip} \ f \ eq)$ (the $g$ and $h$ in the statement of $\mathsf{MIP}$ in Theorem 1). Then we apply the $\mathsf{cut}$ rule on these, resulting in a derivation which is $\circeq$-related to the original $f$.

In Agda, proving proof-relevant interpolation translates to the construction of the following function:
\[
\begin{array}{l}
\mathsf{cut\text{-}intrp} : (f : V \vdash C) ~ (eq : V \equiv \sub{p}{U}) 
\\
\quad \to \mathsf{cut} ~ (\mathsf{MIP}.h ~ (\mathsf{mip} ~ f ~ eq)) ~ (\mathsf{MIP}.g ~ (\mathsf{mip} ~ f ~ eq)) ~ \mf{refl} 
\circeq 
\subst~ (\lambda x.\ x \vdash C)~eq~f
\end{array}
\]
% cut-intrp : ∀ {T} (p : Path T) U {V C}
%   → (f : V ⊢ C) (eq : V ≡ sub p U) 
%   →  cut p (MIP.h (mip p U f eq)) (MIP.g (mip p U f eq)) refl ≗ subst-cxt eq f
The term $f$ has type $V \vdash C$, while the derivation on the left-hand-side of $\circeq$ has type $\sub{p}{U} \vdash C$, so we fix this mismatch with an application of $\subst$. %In order to state that the two derivations are $\circeq$-related we need to substitute the context in the type of $f$ using the equality proof $eq : V \equiv \text{sub} \ p \ U$.
The definition of $\mathsf{cut\text{-}intrp}$ proceeds by pattern-matching on the argument $f$, again crucially employing the technical lemma $\subeq$.


\section{Conclusions}

We have presented an Agda formalization of \NL, showcasing the proofs of two major logical properties: cut admissibility and proof-relevant Maehara interpolation. The key technical contribution is the formal characterization of equality of substituted trees, which serves as a fundamental lemma for the formalization of the aforementioned properties (and for proving other properties in the future, such as uniform interpolation \cite{alizadeh:2014} for an extension of \NL\ with additives).
While cut admissibility and the standard Maehara interpolation property for \NL\ have been established in previous research, our formalization also offers some new theoretical results: a proof-relevant version of \MIP\ and the well-definedness of $\cut$ and $\mf{mip}$ with respect to permutative conversions.
%interpolation First, our Agda formalization of the case distinction type for trees provides a rigorous foundation that can be reused in further research such as uniform interpolation \cite{alizadeh:2014}. Second, our proof-relevant interpolation results, demonstrating that the Maehara interpolation procedure is well-defined with respect to equivalence of derivations, is new theoretical result of \NL.

For many substructural logics, the variable condition in the Maehara interpolation property can be strengthened to include the multiplicity \cite{moot:categorial:2012} and the polarity \cite{roorda1991} of occurrences of atomic formulae. This is true for \NL\ and we plan to formalize these upgrades of the variable condition $\mf{VarCond}$ in future work.

The well-definedness of $\mf{mip}$ wrt. $\circeq$  is attainable in \NL, but it cannot be proved for more structured logics (such as the associative Lambek calculus, or even a semi-associative fragment \cite{VW2025}) without relaxing the equivalence of interpolation triples. In particular, one cannot expect the interpolant formulae to be syntactically equal, as in our type $\MIPeq ~ m_1 ~ m_2$. A possible relaxation would be replacing equality by logical equivalence. 
%for nonassociative Lambek calculus because the logic does not contain complicated equivalences of formulae, making the interpolation triple straightforward to define. We anticipate that extending this approach to the associative or semi-associative Lambek calculus \cite{VW2025} would be more challenging, as those systems involve more complex equational theories on formulae.

From a practical perspective, it is worth mentioning that this Agda formalization is computationally intensive. The type-checking time for some files is quite substantial: the well-definedness proof $\mathsf{mip{\circeq}}$ %(\href{https://github.com/cswphilo/nonassociative-Lambek/blob/main/code/IntrpWellDefined.agda}{$\mf{IntrpWellDefined.agda}$})
takes ${\sim}$10 minutes to type-check, while the associativity of $\cut$ %(\href{https://github.com/cswphilo/nonassociative-Lambek/blob/main/code/CutAssociativities.agda}{$\mf{CutAssociativities.agda}$})
and the well-definedness proofs $\cut{\circeq}_1$ and $\cut{\circeq}_2$
%(\href{https://github.com/cswphilo/nonassociative-Lambek/blob/main/code/CutCongruence.agda}{$\mf{CutCongruence.agda}$})
require >2 hours on a MacBook Pro 2020 with 2 GHz Intel Core i5.
In future work, we plan to work on the code in order to reduce the compilation time.

\begin{credits}
\subsubsection{\ackname} This work was supported by the Estonian Research Council grant PSG749. 

% \subsubsection{\discintname}
% It is now necessary to declare any competing interests or to specifically
% state that the authors have no competing interests. Please place the
% statement with a bold run-in heading in small font size beneath the
% (optional) acknowledgments\footnote{If EquinOCS, our proceedings submission
% system, is used, then the disclaimer can be provided directly in the system.},
% for example: The authors have no competing interests to declare that are
% relevant to the content of this article. Or: Author A has received research
% grants from Company W. Author B has received a speaker honorarium from
% Company X and owns stock in Company Y. Author C is a member of committee Z.
\end{credits}
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{tableaux}
%
\end{document}
